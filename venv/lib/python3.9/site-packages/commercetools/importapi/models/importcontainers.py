# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import ImportResourceType

if typing.TYPE_CHECKING:
    from .common import ImportResourceType

__all__ = [
    "ImportContainer",
    "ImportContainerDraft",
    "ImportContainerPagedResponse",
    "ImportContainerUpdateDraft",
]


class ImportContainer(_BaseType):
    """Serves as the entry point of resources.
    An Import Container is not resource type-specific.

    """

    #: User-defined unique identifier for the ImportContainer.
    #: Keys can only contain alphanumeric characters (a-Z, 0-9), underscores and hyphens (_, -).
    key: str
    #: The [resource type](#importresourcetype) the ImportContainer is able to handle.
    #: If not present, the ImportContainer is able to import all of the supported [ImportResourceTypes](#importresourcetype).
    resource_type: typing.Optional["ImportResourceType"]
    #: The version of the ImportContainer.
    version: int
    #: The time when the ImportContainer was created.
    created_at: datetime.datetime
    #: The last time when the ImportContainer was modified.
    last_modified_at: datetime.datetime

    def __init__(
        self,
        *,
        key: str,
        resource_type: typing.Optional["ImportResourceType"] = None,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime
    ):
        self.key = key
        self.resource_type = resource_type
        self.version = version
        self.created_at = created_at
        self.last_modified_at = last_modified_at

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ImportContainer":
        from ._schemas.importcontainers import ImportContainerSchema

        return ImportContainerSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.importcontainers import ImportContainerSchema

        return ImportContainerSchema().dump(self)


class ImportContainerDraft(_BaseType):
    """The representation sent to the server when creating an [ImportContainer](#importcontainer)."""

    #: User-defined unique identifier of the ImportContainer.
    #: Keys can only contain alphanumeric characters (a-Z, 0-9), underscores and hyphens (_, -).
    key: str
    #: The [resource type](#importresourcetype) to be imported.
    #: If not given, the ImportContainer is able to import all of the supported [ImportResourceTypes](#importresourcetype).
    resource_type: typing.Optional["ImportResourceType"]

    def __init__(
        self, *, key: str, resource_type: typing.Optional["ImportResourceType"] = None
    ):
        self.key = key
        self.resource_type = resource_type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ImportContainerDraft":
        from ._schemas.importcontainers import ImportContainerDraftSchema

        return ImportContainerDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.importcontainers import ImportContainerDraftSchema

        return ImportContainerDraftSchema().dump(self)


class ImportContainerUpdateDraft(_BaseType):
    """The representation sent to the server when updating an import container."""

    #: Current version of the ImportContainer.
    version: int
    #: The [resource type](#importresourcetype) to be imported.
    #: If not given, the ImportContainer is able to import all of the supported [ImportResourceTypes](#importresourcetype).
    resource_type: typing.Optional["ImportResourceType"]

    def __init__(
        self,
        *,
        version: int,
        resource_type: typing.Optional["ImportResourceType"] = None
    ):
        self.version = version
        self.resource_type = resource_type

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ImportContainerUpdateDraft":
        from ._schemas.importcontainers import ImportContainerUpdateDraftSchema

        return ImportContainerUpdateDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.importcontainers import ImportContainerUpdateDraftSchema

        return ImportContainerUpdateDraftSchema().dump(self)


class ImportContainerPagedResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) for [ImportContainers](#importcontainer).
    Used as a response to a query request for [ImportContainers](#importcontainer).

    """

    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: The actual number of results returned.
    count: int
    #: The total number of results matching the query.
    total: int
    #: The array of Import Containers matching the query.
    results: typing.List["ImportContainer"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: int,
        results: typing.List["ImportContainer"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ImportContainerPagedResponse":
        from ._schemas.importcontainers import ImportContainerPagedResponseSchema

        return ImportContainerPagedResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.importcontainers import ImportContainerPagedResponseSchema

        return ImportContainerPagedResponseSchema().dump(self)
