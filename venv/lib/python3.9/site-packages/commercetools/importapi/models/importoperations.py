# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import ProcessingState

if typing.TYPE_CHECKING:
    from .common import ProcessingState, UnresolvedReferences
    from .errors import ErrorObject

__all__ = [
    "ImportOperation",
    "ImportOperationPagedResponse",
    "ImportOperationState",
    "ImportOperationStatus",
]


class ImportOperation(_BaseType):
    """Import Operation describes the import status of a specific resource."""

    #: The version of the ImportOperation.
    version: int
    #: The key of the [importContainer](/import-container#importcontainer).
    import_container_key: str
    #: The key of the resource.
    resource_key: str
    #: The ID of the ImportOperation.
    id: str
    #: The import status of the resource. Set to `rejected` or `validationFailed` if the import of the resource was not successful.
    state: "ProcessingState"
    #: The version of the imported resource when the import was successful.
    resource_version: typing.Optional[int]
    #: Contains an error if the import of the resource was not successful. See [Errors](/error).
    errors: typing.Optional[typing.List["ErrorObject"]]
    #: In case of unresolved status this array will show the unresolved references
    unresolved_references: typing.Optional[typing.List["UnresolvedReferences"]]
    #: The time when the ImportOperation was created.
    created_at: datetime.datetime
    #: The last time When the ImportOperation was modified.
    last_modified_at: datetime.datetime
    #: The expiration time of the ImportOperation.
    expires_at: datetime.datetime

    def __init__(
        self,
        *,
        version: int,
        import_container_key: str,
        resource_key: str,
        id: str,
        state: "ProcessingState",
        resource_version: typing.Optional[int] = None,
        errors: typing.Optional[typing.List["ErrorObject"]] = None,
        unresolved_references: typing.Optional[
            typing.List["UnresolvedReferences"]
        ] = None,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        expires_at: datetime.datetime
    ):
        self.version = version
        self.import_container_key = import_container_key
        self.resource_key = resource_key
        self.id = id
        self.state = state
        self.resource_version = resource_version
        self.errors = errors
        self.unresolved_references = unresolved_references
        self.created_at = created_at
        self.last_modified_at = last_modified_at
        self.expires_at = expires_at

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ImportOperation":
        from ._schemas.importoperations import ImportOperationSchema

        return ImportOperationSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.importoperations import ImportOperationSchema

        return ImportOperationSchema().dump(self)


class ImportOperationPagedResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) for Import Operations."""

    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: The actual number of results returned.
    count: int
    #: The total number of import operations matching the query.
    total: int
    #: The array of Import Operations matching the query.
    results: typing.List["ImportOperation"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: int,
        results: typing.List["ImportOperation"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ImportOperationPagedResponse":
        from ._schemas.importoperations import ImportOperationPagedResponseSchema

        return ImportOperationPagedResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.importoperations import ImportOperationPagedResponseSchema

        return ImportOperationPagedResponseSchema().dump(self)


class ImportOperationState(enum.Enum):
    """Describes the validation state of a newly created [ImportOperation](#importoperation)."""

    PROCESSING = "processing"
    VALIDATION_FAILED = "validationFailed"


class ImportOperationStatus(_BaseType):
    #: The ID of the [ImportOperation](#importoperation).
    operation_id: typing.Optional[str]
    #: The validation state of the [ImportOperation](#importoperation).
    state: "ImportOperationState"
    #: The validation errors for the [ImportOperation](#importoperation).
    #: See [Errors](/error).
    errors: typing.Optional[typing.List["ErrorObject"]]

    def __init__(
        self,
        *,
        operation_id: typing.Optional[str] = None,
        state: "ImportOperationState",
        errors: typing.Optional[typing.List["ErrorObject"]] = None
    ):
        self.operation_id = operation_id
        self.state = state
        self.errors = errors

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ImportOperationStatus":
        from ._schemas.importoperations import ImportOperationStatusSchema

        return ImportOperationStatusSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.importoperations import ImportOperationStatusSchema

        return ImportOperationStatusSchema().dump(self)
